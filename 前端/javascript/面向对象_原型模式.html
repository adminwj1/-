<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>面向对象_原型模式</title>
    <script>
        function Person(name, age, job){
            // 属性使用构造函数
            this.name = name;
            this.age = age;
            this.job = job;
        };
        // 将方法绑定在原型上面
        Person.prototype.showname = function(){
            console.log(this.name);
        };

        Person.prototype.showage = function(){
            console.log(this.age);
        };

        Person.prototype.showjob = function(){
            console.log(this.job);
        };


        var Tom = new Person('tom', 18, 'engineer');
        var jack = new Person('jack', 19, 'worker');

        // 先在自己的对象中找是否有方法，如果没有再去原型里面找。自己的对象中如果有对应的方法，将会替换原型中的方法，但不会影响原型中的方法。
        // 在对象上重写一个方法不会影响到原型的方法
        Tom.showage = function(){
            console.log('我的年龄是'+ this.age);
        };

        Tom.showage();
        jack.showage();
        // 这里返回false，应为Tom.showage和jack.showage没有访问相同的方法，Tom.showage访问的是自己的对象中自带的showage方法
        
        console.log(Tom.showage == jack.showage);   
    </script>
</head>
<body>
    
</body>
</html>